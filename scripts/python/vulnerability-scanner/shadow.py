#!/usr/bin/env python3
"""
SHADOW - Security Vulnerability Scanner
========================================

An advanced template-based vulnerability scanner designed for security professionals
and ethical hackers to identify potential security weaknesses in web applications,
networks, and services.

Key Features:
- Template-based scanning using YAML configuration files
- Asynchronous HTTP requests for improved performance
- Support for multiple protocols (HTTP, HTTPS, DNS)
- Comprehensive vulnerability detection patterns
- Detailed reporting with severity classifications
- Extensible template system for custom vulnerability checks
- Multi-target scanning capabilities
- Rate limiting and respectful scanning practices

Scanner Capabilities:
1. Web Application Security Testing:
   - Directory traversal vulnerabilities
   - SQL injection detection patterns
   - Cross-site scripting (XSS) detection
   - Authentication bypass attempts
   - Information disclosure checks

2. Network Security Assessment:
   - Port scanning and service detection
   - DNS enumeration and subdomain discovery
   - SSL/TLS configuration analysis
   - Banner grabbing and version detection

3. Template-Based Scanning:
   - YAML-based vulnerability templates
   - Custom template creation support
   - Community template sharing
   - Severity classification system

Security & Ethics:
- Designed for authorized penetration testing only
- Includes rate limiting to prevent DoS
- Comprehensive logging for audit trails
- Follows responsible disclosure practices

Usage Examples:
    python shadow.py --target example.com
    python shadow.py --target-list targets.txt --templates custom_templates/
    python shadow.py --target 192.168.1.100 --output-format json
    python shadow.py --target example.com --severity high,critical

Dependencies:
    - requests: HTTP client library
    - aiohttp: Asynchronous HTTP client
    - pyyaml: YAML template parsing
    - dnspython: DNS resolution capabilities

Author: Nerva Security Team
License: MIT (Educational and Authorized Testing Only)
Version: 3.0.0

DISCLAIMER: This tool is for educational purposes and authorized penetration 
testing only. Users are responsible for ensuring they have proper authorization 
before scanning any targets. Unauthorized scanning may be illegal.
"""

import os
import yaml
import requests
from ipaddress import ip_network, ip_address
import dns.resolver
import asyncio
import aiohttp
import logging
import argparse
import json
from datetime import datetime

# Configure comprehensive logging for security audit trails
logging.basicConfig(
    level=logging.INFO, 
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(f'shadow_scan_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def print_banner():
    """
    Display the SHADOW scanner banner with attribution and warnings.
    
    The banner serves as both branding and a reminder of the tool's intended
    use for authorized security testing only.
    """
    banner = """
    
     █████████  █████   █████   █████████   ██████████      ███████    █████   ███   █████
 ███░░░░░███░░███   ░░███   ███░░░░░███ ░░███░░░░███   ███░░░░░███ ░░███   ░███  ░░███ 
░███    ░░░  ░███    ░███  ░███    ░███  ░███   ░░███ ███     ░░███ ░███   ░███   ░███ 
░░█████████  ░███████████  ░███████████  ░███    ░███░███      ░███ ░███   ░███   ░███ 
 ░░░░░░░░███ ░███░░░░░███  ░███░░░░░███  ░███    ░███░███      ░███ ░░███  █████  ███  
 ███    ░███ ░███    ░███  ░███    ░███  ░███    ███ ░░███     ███   ░░░█████░█████░   
░░█████████  █████   █████ █████   █████ ██████████   ░░░███████░      ░░███ ░░███     
 ░░░░░░░░░  ░░░░░   ░░░░░ ░░░░░   ░░░░░ ░░░░░░░░░░      ░░░░░░░         ░░░   ░░░      
                                                                                                                                                                      
    SHADOW - Security Vulnerability Scanner v3.0.0
    ⚠️  FOR AUTHORIZED PENETRATION TESTING ONLY ⚠️
    """
    print(banner)

class VulnerabilityScanner:
    """
    Advanced Template-Based Vulnerability Scanner
    
    This class implements a comprehensive vulnerability scanning engine that uses
    YAML-based templates to define vulnerability detection patterns. It supports
    asynchronous scanning for improved performance and provides detailed reporting
    of discovered security issues.
    
    Architecture:
    - Template Engine: Loads and parses YAML vulnerability templates
    - HTTP Scanner: Asynchronous web application testing
    - DNS Scanner: Domain and subdomain enumeration
    - Report Generator: Structured vulnerability reporting
    - Rate Limiter: Respectful scanning to prevent service disruption
    
    Attributes:
        templates_dir (str): Directory containing vulnerability templates
        output_dir (str): Directory for scan reports and logs
        templates (List[Dict]): Loaded vulnerability templates
        results (List[Dict]): Accumulated scan results
        max_concurrent (int): Maximum concurrent requests
        scan_delay (float): Delay between requests in seconds
    """
    
    def __init__(self, templates_dir="./templates", output_dir="./reports", max_concurrent=10, scan_delay=0.1):
        """
        Initialize the vulnerability scanner with configuration options.
        
        Args:
            templates_dir (str): Path to directory containing YAML templates
            output_dir (str): Path to directory for output reports
            max_concurrent (int): Maximum number of concurrent HTTP requests
            scan_delay (float): Delay between requests to prevent overwhelming targets
        """
        self.templates_dir = templates_dir
        self.output_dir = output_dir
        self.templates = []
        self.results = []
        self.max_concurrent = max_concurrent
        self.scan_delay = scan_delay
        
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        # Log scanner initialization
        logger.info(f"SHADOW Scanner initialized")
        logger.info(f"Templates directory: {templates_dir}")
        logger.info(f"Output directory: {output_dir}")
        logger.info(f"Max concurrent requests: {max_concurrent}")
        logger.info(f"Scan delay: {scan_delay}s")
    
    def load_templates(self):
        """
        Load vulnerability detection templates from YAML files.
        
        This method discovers and parses all YAML files in the templates directory,
        validating their structure and preparing them for use in vulnerability
        detection. If no templates are found, it creates sample templates to help
        users get started.
        
        Template Structure:
            id: unique-template-identifier
            info:
                name: Human-readable vulnerability name
                severity: critical|high|medium|low|info
                description: Detailed vulnerability description
                tags: [list, of, relevant, tags]
            requests:
                - method: HTTP method (GET, POST, etc.)
                  path: URL path to test
                  headers: Custom HTTP headers
                  expected: Expected response patterns
                  
        Side Effects:
            - Populates self.templates with parsed template data
            - Creates sample templates if none exist
            - Logs template loading statistics
        """
        if not os.path.exists(self.templates_dir):
            logger.warning(f"Templates directory '{self.templates_dir}' not found. Creating sample template.")
            self.create_sample_template()
            return
        
        template_count = 0
        for filename in os.listdir(self.templates_dir):
            if filename.endswith((".yaml", ".yml")):
                try:
                    with open(os.path.join(self.templates_dir, filename), 'r') as file:
                        template = yaml.safe_load(file)
                        if template:
                            self.templates.append(template)
                            template_count += 1
                except Exception as e:
                    logger.error(f"Error loading template {filename}: {e}")
        
        logger.info(f"Loaded {template_count} vulnerability templates")
    
    def create_sample_template(self):
        """Create a sample vulnerability template."""
        os.makedirs(self.templates_dir, exist_ok=True)
        
        sample_template = {
            'id': 'sample-directory-listing',
            'info': {
                'name': 'Directory Listing Enabled',
                'author': 'SHADOW Scanner',
                'severity': 'medium',
                'description': 'Checks for directory listing vulnerability',
                'tags': ['directory-listing', 'information-disclosure']
            },
            'requests': [
                {
                    'method': 'GET',
                    'path': '/',
                    'headers': {
                        'User-Agent': 'SHADOW-Scanner/1.0'
                    },
                    'expected': [
                        {
                            'status': 200,
                            'body_contains': 'Index of /'
                        }
                    ]
                }
            ]
        }
        
        with open(os.path.join(self.templates_dir, 'sample-template.yaml'), 'w') as f:
            yaml.dump(sample_template, f, default_flow_style=False)
        
        logger.info(f"Created sample template at {self.templates_dir}/sample-template.yaml")
    
    def add_scheme(self, url):
        """Add HTTP/HTTPS scheme to URL if missing."""
        if not url.startswith(('http://', 'https://')):
            return ['http://' + url, 'https://' + url]
        return [url]
    
    async def run_template(self, template, target):
        """Run a vulnerability template against a target."""
        results = []
        
        # Handle HTTP requests
        if 'requests' in template:
            results.extend(await self.run_http_requests(template, target))
        
        # Handle DNS checks
        if 'dns' in template:
            results.extend(self.run_dns_checks(template['dns'], target))
        
        return results
    
    async def run_http_requests(self, template, target):
        """Execute HTTP requests from template."""
        results = []
        urls = self.add_scheme(target)
        
        timeout = aiohttp.ClientTimeout(total=30)
        
        async with aiohttp.ClientSession(timeout=timeout) as session:
            for url in urls:
                for request in template.get('requests', []):
                    try:
                        full_url = url + request.get('path', '/')
                        headers = request.get('headers', {})
                        method = request.get('method', 'GET').upper()
                        
                        async with session.request(method, full_url, headers=headers) as response:
                            result = await self.process_response(response, request, template, full_url)
                            results.append(result)
                            
                    except asyncio.TimeoutError:
                        logger.warning(f"Timeout for {full_url}")
                    except Exception as e:
                        logger.error(f"Request to {full_url} failed: {e}")
        
        return results
    
    async def process_response(self, response, request, template, url):
        """Process HTTP response and check for vulnerabilities."""
        body = await response.text()
        
        result = {
            'template_id': template.get('id', 'unknown'),
            'template_name': template.get('info', {}).get('name', 'Unknown'),
            'severity': template.get('info', {}).get('severity', 'info'),
            'url': url,
            'status': 'safe',
            'response_status': response.status,
            'response_size': len(body),
            'timestamp': datetime.now().isoformat()
        }
        
        # Check expected conditions
        for expected in request.get('expected', []):
            status_match = expected.get('status') == response.status
            body_contains = expected.get('body_contains', '') in body
            
            if status_match and (not expected.get('body_contains') or body_contains):
                result['status'] = 'vulnerable'
                result['description'] = template.get('info', {}).get('description', '')
                result['matched_condition'] = expected
                break
        
        return result
    
    def run_dns_checks(self, dns_section, target):
        """Run DNS-based vulnerability checks."""
        results = []
        
        for check in dns_section:
            try:
                record_type = check.get('type', 'A')
                answers = dns.resolver.resolve(target, record_type)
                
                for rdata in answers:
                    result = {
                        'type': 'dns',
                        'target': target,
                        'record_type': record_type,
                        'record_value': str(rdata),
                        'status': 'found',
                        'timestamp': datetime.now().isoformat()
                    }
                    results.append(result)
                    
            except dns.resolver.NoAnswer:
                logger.debug(f"No {record_type} record for {target}")
            except dns.resolver.NXDOMAIN:
                logger.debug(f"Domain {target} does not exist")
            except Exception as e:
                logger.error(f"DNS check failed for {target}: {e}")
        
        return results
    
    def parse_targets(self, targets):
        """Parse and expand target list."""
        expanded_targets = []
        
        for target in targets:
            if '*' in target:
                # Handle wildcard domains (simplified)
                expanded_targets.append(target.replace('*.', 'www.'))
            elif self.is_valid_ip_range(target):
                # Handle IP ranges
                try:
                    network = ip_network(target, strict=False)
                    expanded_targets.extend([str(ip) for ip in network.hosts()][:100])  # Limit to 100 IPs
                except Exception as e:
                    logger.error(f"Invalid IP range {target}: {e}")
            else:
                expanded_targets.append(target)
        
        return expanded_targets
    
    def is_valid_ip_range(self, target):
        """Check if target is a valid IP range."""
        try:
            ip_network(target, strict=False)
            return True
        except ValueError:
            return False
    
    def load_targets_from_file(self, file_path):
        """Load targets from file."""
        try:
            with open(file_path, 'r') as file:
                if file_path.endswith(('.yaml', '.yml')):
                    data = yaml.safe_load(file)
                    return data if isinstance(data, list) else [data]
                else:
                    return [line.strip() for line in file.readlines() if line.strip()]
        except Exception as e:
            logger.error(f"Error loading targets from {file_path}: {e}")
            return []
    
    def generate_report(self, results, format='text'):
        """Generate vulnerability report."""
        if format == 'json':
            return self.generate_json_report(results)
        else:
            return self.generate_text_report(results)
    
    def generate_text_report(self, results):
        """Generate text-based report."""
        report = []
        report.append("=" * 60)
        report.append("SHADOW VULNERABILITY SCAN REPORT")
        report.append("=" * 60)
        report.append(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"Total Checks: {len(results)}")
        
        vulnerable_count = sum(1 for r in results if r.get('status') == 'vulnerable')
        report.append(f"Vulnerabilities Found: {vulnerable_count}")
        report.append("")
        
        # Group results by severity
        severity_groups = {}
        for result in results:
            if result.get('status') == 'vulnerable':
                severity = result.get('severity', 'info')
                if severity not in severity_groups:
                    severity_groups[severity] = []
                severity_groups[severity].append(result)
        
        # Report by severity
        for severity in ['critical', 'high', 'medium', 'low', 'info']:
            if severity in severity_groups:
                report.append(f"\n{severity.upper()} SEVERITY VULNERABILITIES:")
                report.append("-" * 40)
                
                for vuln in severity_groups[severity]:
                    report.append(f"Template: {vuln.get('template_name', 'Unknown')}")
                    report.append(f"URL: {vuln.get('url', 'N/A')}")
                    report.append(f"Description: {vuln.get('description', 'No description')}")
                    report.append(f"Status Code: {vuln.get('response_status', 'N/A')}")
                    report.append("")
        
        return "\n".join(report)
    
    def generate_json_report(self, results):
        """Generate JSON report."""
        report_data = {
            'scan_info': {
                'timestamp': datetime.now().isoformat(),
                'total_checks': len(results),
                'vulnerabilities_found': sum(1 for r in results if r.get('status') == 'vulnerable')
            },
            'results': results
        }
        return json.dumps(report_data, indent=2)
    
    def save_report(self, report, targets, format='text'):
        """Save report to file."""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        target_str = "_".join(targets[:3])  # Use first 3 targets for filename
        if len(targets) > 3:
            target_str += f"_and_{len(targets)-3}_more"
        
        extension = 'json' if format == 'json' else 'txt'
        filename = f"shadow_scan_{target_str}_{timestamp}.{extension}"
        filepath = os.path.join(self.output_dir, filename)
        
        try:
            with open(filepath, 'w') as f:
                f.write(report)
            logger.info(f"Report saved to: {filepath}")
            return filepath
        except Exception as e:
            logger.error(f"Error saving report: {e}")
            return None
    
    async def scan(self, targets, output_format='text', save_report=True):
        """Main scanning function."""
        logger.info(f"Starting vulnerability scan of {len(targets)} targets")
        
        all_results = []
        
        for target in targets:
            logger.info(f"Scanning target: {target}")
            
            for template in self.templates:
                try:
                    results = await self.run_template(template, target)
                    all_results.extend(results)
                except Exception as e:
                    logger.error(f"Error running template {template.get('id', 'unknown')} on {target}: {e}")
        
        # Generate report
        report = self.generate_report(all_results, output_format)
        
        if save_report:
            self.save_report(report, targets, output_format)
        
        return all_results, report

async def main():
    parser = argparse.ArgumentParser(
        description='SHADOW - Security Vulnerability Scanner',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('-t', '--targets', nargs='+', help='Target URLs or IPs')
    parser.add_argument('-f', '--file', help='File containing targets')
    parser.add_argument('--templates', default='./templates', help='Templates directory')
    parser.add_argument('--output', default='./reports', help='Output directory')
    parser.add_argument('--format', choices=['text', 'json'], default='text', help='Output format')
    parser.add_argument('--no-save', action='store_true', help='Don\'t save report to file')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    print_banner()
    
    # Initialize scanner
    scanner = VulnerabilityScanner(args.templates, args.output)
    scanner.load_templates()
    
    if not scanner.templates:
        logger.error("No templates loaded. Cannot proceed with scan.")
        return
    
    # Collect targets
    targets = []
    
    if args.file:
        targets.extend(scanner.load_targets_from_file(args.file))
    
    if args.targets:
        targets.extend(args.targets)
    
    if not targets:
        logger.error("No targets specified. Use -t or -f option.")
        return
    
    # Parse and expand targets
    targets = scanner.parse_targets(targets)
    targets = list(dict.fromkeys(targets))  # Remove duplicates
    
    # Run scan
    try:
        results, report = await scanner.scan(
            targets, 
            args.format, 
            not args.no_save
        )
        
        print("\n" + report)
        
        vulnerable_count = sum(1 for r in results if r.get('status') == 'vulnerable')
        if vulnerable_count > 0:
            logger.warning(f"Found {vulnerable_count} potential vulnerabilities!")
        else:
            logger.info("No vulnerabilities detected.")
            
    except KeyboardInterrupt:
        logger.info("Scan interrupted by user")
    except Exception as e:
        logger.error(f"Scan failed: {e}")

if __name__ == '__main__':
    asyncio.run(main())
